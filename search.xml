<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spark编程</title>
      <link href="/posts/2785693311/"/>
      <url>/posts/2785693311/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spark处理系统</title>
      <link href="/posts/2951632131/"/>
      <url>/posts/2951632131/</url>
      <content type="html"><![CDATA[<p>介绍大数据处理框架Spark架构设计，执行流程及其容错措施</p><a id="more"></a><h2 id="Spark-特点"><a href="#Spark-特点" class="headerlink" title="Spark 特点"></a>Spark 特点</h2><ul><li>运行速度快<ul><li>使用DAG执行引擎以 <strong>支持循环数据流与内存计算</strong></li></ul></li><li>容易使用<ul><li>支持Scala，Java，Python和R，通过Spark Shell进行 <strong>交互式编程</strong></li></ul></li><li>通用性<ul><li>提供了完整强大的技术栈，包括SQL查询，流式计算、机器学习和图算法组件</li></ul></li><li>运行模式多样<ul><li>可运行于 <strong>独立的集群模式</strong> 中，可运行于Hadoop，Amazon EC2等云环境中。</li><li>可访问HDFS、Hbase、HIVE等多种数据源<h2 id="Spark-vs-Mapreduce"><a href="#Spark-vs-Mapreduce" class="headerlink" title="Spark vs. Mapreduce"></a>Spark vs. Mapreduce</h2></li></ul></li></ul><h3 id="Hadoop-MapReduce-局限性"><a href="#Hadoop-MapReduce-局限性" class="headerlink" title="Hadoop MapReduce 局限性"></a>Hadoop MapReduce 局限性</h3><ul><li>表达能力有限<ul><li>计算都要转化成Map和Reduce两个函数，难以描述复杂的数据处理过程，如join过程</li></ul></li><li>磁盘IO开销大<ul><li>输入、输出、以及shuffle中间结果都需要读写磁盘。IO开销较大</li></ul></li><li>延迟高<ul><li>有依赖<ul><li>一次计算可能需要分解成一系列按顺序执行的的Mapreduce任务，任务之间的衔接由于涉及到IO开销会产生较高延迟（job之间的衔接涉及IO）</li></ul></li><li>无依赖关系<ul><li>在前一个job执行完成之前，其他job依然无法开始。Hadoop一次只执行一个job，无依赖关系的作业不能做到并行</li></ul></li></ul></li></ul><h3 id="Spark-改进"><a href="#Spark-改进" class="headerlink" title="Spark 改进"></a>Spark 改进</h3><ul><li>表达能力灵活<ul><li>增加join等更多复杂的函数，可以串联为DAG。</li></ul></li><li>提供内存计算<ul><li>中间结果（非shuffle阶段）直接放到内存中，带来了更高的迭代运算效率</li></ul></li><li>延迟低（多个job作为一整个job）<ul><li>将原来的多个job作为一个job的多个阶段<ul><li>有依赖关系：多个阶段之间的衔接 <strong>尽量</strong> 写内存</li><li>无依赖关系：多个阶段可以同时执行</li></ul></li></ul></li><li>Spark基于<code>DAG</code>的任务调度执行机制，要优于MapReduce的迭代执行机制</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><ul><li>Resilient Distributed Dataset（弹性分布式数据集）<ul><li>可恢复性</li><li>分布式内存的一个抽象概念</li><li>提供了一种高度受限的共享内存模型</li></ul></li></ul><h3 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h3><ul><li>Directed Acyclic Graph（有向无环图）</li><li>反映RDD之间的依赖关系</li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul><li>是运行在工作节点（WorkerNode）上的一个进程，负责运行任务，并为应用程序存储数据</li></ul><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><ul><li>运行在Executor上的工作单元</li></ul><h3 id="job"><a href="#job" class="headerlink" title="job"></a>job</h3><ul><li>一个作业包含多个RDD及作用于相应RDD上的各种操作</li></ul><h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h3><ul><li>是作业的基本调度单位</li><li>一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”</li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh1zwbsyuj30db05k74l.jpg" alt=""></li></ul><h3 id="Master（管理整个系统）"><a href="#Master（管理整个系统）" class="headerlink" title="Master（管理整个系统）"></a>Master（管理整个系统）</h3><ul><li>集群资源管理器（cluster Manager）<ul><li>可以是spark自带的资源管理器</li><li>可以是YARN或mesos等资源管理框架</li></ul></li></ul><h3 id="Worker（运行作业的工作节点）"><a href="#Worker（运行作业的工作节点）" class="headerlink" title="Worker（运行作业的工作节点）"></a>Worker（运行作业的工作节点）</h3><ul><li>运行作业任务的工作节点（workernode）<ul><li>每个工作节点上负责具体任务的执行进程（Executor）<ul><li>利用 <strong>多线程</strong> 来执行具体的任务，减少任务的启动开销<ul><li>hadoop采用多进程</li></ul></li><li>Executor中有一个BlockManager存储模块，<strong>会将内存和磁盘共同作为设备</strong>，当需要多轮迭代运算时，可以将中间结果存储到这个存储模块里，而不需要读写到HDFS等文件系统里，减少IO开销<ul><li>在交互式场景中，预先将表缓存到该存储系统上，提高IO性能</li></ul></li><li>负责任务执行的线程（Task）</li></ul></li></ul></li></ul><h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><ul><li>每个应用的任务控制节点（Driver）</li></ul><h3 id="相互关系"><a href="#相互关系" class="headerlink" title="相互关系"></a>相互关系</h3><ul><li>逻辑执行角度<ul><li>一个application=一个或多个DAG</li><li>一个DAG=一个或多个Stage</li><li>一个Stage=若干 <strong>窄依赖</strong> 的RDD转换</li></ul></li><li>物理执行角度<ul><li>一个application=一个或多个Job</li><li>一个Job=一个过多个TaskSet</li><li>一个TaskSet=多个 <strong>没有shuffle关系</strong>的Task</li></ul></li></ul><h3 id="Spark架构图"><a href="#Spark架构图" class="headerlink" title="Spark架构图"></a>Spark架构图</h3><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh67d17w7j30lr09v76c.jpg" alt=""></li></ul><h2 id="Spark工作流程"><a href="#Spark工作流程" class="headerlink" title="Spark工作流程"></a>Spark工作流程</h2><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh6hwoh7jj30l50c3wgt.jpg" alt=""></li></ul><h3 id="Spark运行基本流程"><a href="#Spark运行基本流程" class="headerlink" title="Spark运行基本流程"></a>Spark运行基本流程</h3><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh6k9spiqj30cs097t9o.jpg" alt=""></li></ul><h4 id="Driver向集群管理器申请资源"><a href="#Driver向集群管理器申请资源" class="headerlink" title="Driver向集群管理器申请资源"></a>Driver向集群管理器申请资源</h4><ul><li>当一个Spark任务被提交时，首先构建基本运行环境，即由Driver创建SparkContext，进行资源申请、任务分配和监控<ul><li>向Cluster Manager注册并申请运行Executor</li></ul></li></ul><h4 id="ClusterManager启动Executor"><a href="#ClusterManager启动Executor" class="headerlink" title="ClusterManager启动Executor"></a>ClusterManager启动Executor</h4><ul><li>资源管理器为Executor分配资源，并启动Executor进程<ul><li>Executor运行情况根据<code>心跳</code>机制发送到ClusterManager上</li></ul></li></ul><h4 id="Driver向Executor发送应用程序代码和文件"><a href="#Driver向Executor发送应用程序代码和文件" class="headerlink" title="Driver向Executor发送应用程序代码和文件"></a>Driver向Executor发送应用程序代码和文件</h4><ul><li>SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给<code>DAG Scheduler</code>解析成Stage（Taskset），然后把一个个TaskSet提交给底层调度器TaskScheduler处理</li><li>Executor向SparkContext <strong>申请Task</strong>，Task Scheduler将Task分发给Executor执行，同时SparkContext将应用程序代码发放给Executor</li></ul><h4 id="Executor上执行Task"><a href="#Executor上执行Task" class="headerlink" title="Executor上执行Task"></a>Executor上执行Task</h4><ul><li>Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据并释放所有资源</li></ul><h3 id="Spark运行流程特点"><a href="#Spark运行流程特点" class="headerlink" title="Spark运行流程特点"></a>Spark运行流程特点</h3><ul><li>由专属的Executor进程，并且在Application运行期间一直驻留</li><li>Executor进程以<strong>多线程</strong>方式运行Task</li><li>Spark<strong>运行过程独立于资源管理器</strong>，只要能够获取Executor进程并保持通信即可</li><li>Task采用了 <strong>数据本地性</strong> 和 <strong>推测执行</strong>等优化机制<ul><li>计算向数据靠拢</li><li>推测执行将较慢的任务再次在其他节点启动</li></ul></li></ul><h2 id="RDD抽象"><a href="#RDD抽象" class="headerlink" title="RDD抽象"></a>RDD抽象</h2><h3 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h3><ul><li>在许多迭代算法或交互式计算工具中，不同计算阶段之间重用中间结果</li><li>MapReduce每次把中间结果写到HDFS中，加大IO开销</li><li>RDD提供了抽象的数据结构，不同RDD之间的转换操作形成 <strong>依赖关系</strong>，实现 <strong>管道化</strong>，降低IO开销  </li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>分布式对象集合，本质是一个 <strong>只读</strong>的分区记录集合</li></ul><h4 id="Distrubuted"><a href="#Distrubuted" class="headerlink" title="Distrubuted"></a>Distrubuted</h4><ul><li>每个RDD可以分很多区，每个分区是一个数据集片段</li><li>RDD的不同分区可以保存到集群中的不同节点（实现并行计算）</li></ul><h4 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h4><ul><li>只读，不支持修改</li><li>只能基于稳定的物理存储中的数据集创建RDD</li><li>通过在其他RDD上执行确定的转换操作得到新的RDD<ul><li>map</li><li>join</li><li>group by等</li></ul></li></ul><h4 id="Resilient"><a href="#Resilient" class="headerlink" title="Resilient"></a>Resilient</h4><ul><li>具有可恢复的 <strong>容错特性</strong></li></ul><h3 id="DAG运算操作"><a href="#DAG运算操作" class="headerlink" title="DAG运算操作"></a>DAG运算操作</h3><ul><li>RDD操作支持数据运算</li></ul><h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><ul><li>转换，描述RDD的转换逻辑</li><li>只是记录下一些基础数据集以及RDD生成轨迹，即相互之间的依赖关系</li></ul><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><ul><li>执行计算并制定输出的形式</li><li>标志转换结束，触发DAG生成<ul><li>惰性求值：只有遇到行动操作时，才会发生真正的计算，从血缘关系源头开始（根据DAG），进行物理的转换操作</li></ul></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>Transformation 接受RDD并返回RDD</li><li>Action接受RDD返回非RDD（输出一个值或结果）</li></ul><h4 id="运算操作API"><a href="#运算操作API" class="headerlink" title="运算操作API"></a>运算操作API</h4><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh7vrjcdaj30fy08u772.jpg" alt=""></li><li>wordcount举例<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh7ym2fnzj30k205kdh0.jpg" alt=""></li></ul></li></ul><h3 id="RDDLineage"><a href="#RDDLineage" class="headerlink" title="RDDLineage"></a>RDDLineage</h3><ul><li>DAG拓扑结构<ul><li>RDD读入外部数据源进行创建</li><li>RDD经过一些列的Transformation操作，每次产生不同的RDD，供给下一个转换操作使用<ul><li>最后通过Lineage实现的一系列RDD就可以实现 <strong>管道化</strong></li></ul></li><li>最后一个RDD经过action操作转换，输出到外部数据源</li></ul></li><li>Spark系统保留RDD Lineage的信息<ul><li>容错机制</li></ul></li></ul><h3 id="RDD特性"><a href="#RDD特性" class="headerlink" title="RDD特性"></a>RDD特性</h3><ul><li>高效的容错性</li><li>中间结果持久化到内存</li><li>存放的数据可以使java对象<ul><li>避免了不必要的对象序列化和反序列化开销</li></ul></li></ul><h3 id="RDD依赖关系"><a href="#RDD依赖关系" class="headerlink" title="RDD依赖关系"></a>RDD依赖关系</h3><ul><li>窄依赖（父RDD的一个分区只被一个子RDD的一个分区所使用）<ul><li>一个父RDD的分区对应于一个子RDD的分区</li><li>多个父RDD的分区对应于一个子RDD的分区</li><li>典型操作：map，filter，union</li></ul></li><li>宽依赖<ul><li>存在一个父RDD的一个分区对应一个子RDD的多个分区</li><li>典型操作：groupbykey，sortbykey</li></ul></li><li>特殊：join（分两种情况）<ul><li>对输入协同划分：窄依赖<ul><li>多个父RDD的某一分区的所有key落在子RDD的同一个分区</li></ul></li><li>对输入非协同划分：宽依赖</li></ul></li></ul><h4 id="Shuffle-vs-Pipeline"><a href="#Shuffle-vs-Pipeline" class="headerlink" title="Shuffle vs. Pipeline"></a>Shuffle vs. Pipeline</h4><ul><li>对于窄依赖，以流水线的方式计算所有分区</li><li>对于宽依赖，常伴随shuffle操作，首先要计算好所有父分区数据</li><li>Spark这种依赖关系设计，具有很好的容错性<ul><li>当RDD部分分区数据丢失时，可以通过血缘关系获取足够的信息重新运算并恢复</li><li>窄依赖的恢复更高效</li></ul></li></ul><h3 id="DAG-Stage划分"><a href="#DAG-Stage划分" class="headerlink" title="DAG Stage划分"></a>DAG Stage划分</h3><ul><li>分析各个RDD偏序关系生成DAG</li></ul><h4 id="具体划分方法"><a href="#具体划分方法" class="headerlink" title="具体划分方法"></a>具体划分方法</h4><ul><li>在DAG中进行<strong>反向解析</strong>，遇到宽依赖就断开</li><li>遇到窄依赖就把当前的RDD加入到Stage中</li><li>窄依赖尽量划分在同一个Stage中，可以实现 <strong>流水线计算pipeline</strong></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh97avw5yj30la0c7ad9.jpg" alt=""></li><li>一个DAG图划分为多个阶段后，每个阶段代表一组关联的，相互之间没有依赖关系的任务组成的TaskSet。每个Task交给TaskScheduler处理，之后发给Executor执行</li></ul><h2 id="Stage-类型"><a href="#Stage-类型" class="headerlink" title="Stage 类型"></a>Stage 类型</h2><h3 id="ShuffleMapStage"><a href="#ShuffleMapStage" class="headerlink" title="ShuffleMapStage"></a>ShuffleMapStage</h3><ul><li>输入/输出<ul><li>输入边界可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出</li><li>以Shuffle为输出边界，作为另一个Stage开始</li></ul></li><li>特点<ul><li>不是最终Stage</li><li>输出一定要经过Shuffle过程，作为后续Stage输入</li><li>JOb里可能有可能没有该类型Stage</li></ul></li></ul><h3 id="ResultStage"><a href="#ResultStage" class="headerlink" title="ResultStage"></a>ResultStage</h3><ul><li>输入/输出<ul><li>输入边界可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出</li><li>输出直接产生结果或存储</li></ul></li><li>特点<ul><li>在一个job里必定有该类型Stage</li><li>最终的Stage </li></ul></li></ul><h2 id="DAG运行过程"><a href="#DAG运行过程" class="headerlink" title="DAG运行过程"></a>DAG运行过程</h2><ul><li>创建RDD对象</li><li>SparkContext负责计算RDD之间的依赖关系，构建DAG</li><li>DAGScheduler负责把DAG图分解成多个Stage，每个Stage包含了多个Task</li><li>每个Task被TaskScheduler分发给各个WorkerNode上的Executor去执行</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwh9n5vxr7j30fg05wgm0.jpg" alt=""></li></ul><h2 id="Spark-Shuffle-pipeline"><a href="#Spark-Shuffle-pipeline" class="headerlink" title="Spark Shuffle/pipeline"></a>Spark Shuffle/pipeline</h2><h2 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h2><h3 id="Master-故障"><a href="#Master-故障" class="headerlink" title="Master 故障"></a>Master 故障</h3><ul><li>怎么办？</li></ul><h3 id="Worker-故障"><a href="#Worker-故障" class="headerlink" title="Worker 故障"></a>Worker 故障</h3><h4 id="Lineage机制"><a href="#Lineage机制" class="headerlink" title="Lineage机制"></a>Lineage机制</h4><ul><li>RDD容错特性<ul><li>由于数据只读，需要修改数据，必须从父RDD转换到子RDD，在RDD之间建立血缘关系</li><li>所以不需要通过 <strong>数据冗余</strong>的方式实现容错，只需通过RDD血缘依赖关系重新计算错误的分区，无需回滚整个系统<ul><li>而且重算过程可以在不同节点之间实现并行</li></ul></li><li>只需记录粗粒度的转换操作，不需要记录具体数据的修改，降低容错开销</li></ul></li><li>窄依赖<ul><li>执行某个partition时，检查父亲RDD对应的partition是否存在<ul><li>存在，即可执行当前RDD对应操作</li><li>不存在，重构父亲RDD对应的partition（递归）</li></ul></li></ul></li><li>宽依赖<ul><li>执行某个partition时，检查父亲RDD对应的partition是否存在<ul><li>存在，即可执行当前RDD对应操作</li><li>不存在，重构整个父亲RDD</li></ul></li></ul></li><li>举例<ul><li>HadoopRDD</li><li>FilteredRDD</li><li>joinedRDD</li></ul></li></ul><h4 id="RDD存储机制"><a href="#RDD存储机制" class="headerlink" title="RDD存储机制"></a>RDD存储机制</h4><ul><li>RDD提供的持久化（缓存）接口<ul><li>persist：对一个RDD标记为持久化</li><li>cache<ul><li>相当于persist(MEMORY_ONLY)</li></ul></li><li>可以使用unpersist方法手动地把持久化的RDD从缓存中删除</li></ul></li></ul><h4 id="检查点机制"><a href="#检查点机制" class="headerlink" title="检查点机制"></a>检查点机制</h4><ul><li>前述机制的不足<ul><li>Lineage可能非常长</li><li>RDD存储机制主要面向本地磁盘的存储</li></ul></li><li>检查点机制将RDD写入可靠的 <strong>外部</strong>分布式文件系统，例如HDFS<ul><li>写检查点的过程是一个独立 <strong>job</strong>，作为后台作业运行</li></ul></li><li>在进行故障恢复时，Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，选择最优的恢复策略</li></ul><h2 id="Spark运行示例"><a href="#Spark运行示例" class="headerlink" title="Spark运行示例"></a>Spark运行示例</h2><h3 id="reducebykey"><a href="#reducebykey" class="headerlink" title="reducebykey"></a>reducebykey</h3><ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwhacr65d1j30k00a5gmx.jpg" alt=""></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Distributed Systems </tag>
            
            <tag> Spark </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL(2)</title>
      <link href="/posts/1995768129/"/>
      <url>/posts/1995768129/</url>
      <content type="html"><![CDATA[<p>SQL语言进阶之查询</p><a id="more"></a><h2 id="统计与数据处理"><a href="#统计与数据处理" class="headerlink" title="统计与数据处理"></a>统计与数据处理</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>数据基本统计检索功能</li><li>COUNT(*)<ul><li>统计元组个数</li></ul></li><li>COUNT([DISTINCT]|ALL&lt;列名&gt;)<ul><li>统计一列中值的个数</li></ul></li><li>SUM([DISTINCT]|ALL&lt;列名&gt;)<ul><li>计算一列值的总和</li></ul></li><li>AVG([DISTINCT]|ALL&lt;列名&gt;)<ul><li>计算一列值的平均值</li></ul></li><li>MAX([DISTINCT]|ALL&lt;列名&gt;)<ul><li>计算一列值的最大值</li></ul></li><li>MIN([DISTINCT]|ALL&lt;列名&gt;)<ul><li>计算一列值中的最小值</li></ul></li><li>如果指定<code>DISTINCT</code>则表示计算时要取消指定列中的重复值</li><li>当聚集函数遇到空值时，除COUNT(<em>)外，都跳过空值而只处理非空值，因为COUNT(</em>)是对元组计数，与其是否取空值无关。</li></ul><h3 id="GROUP-BY-细化聚集函数的作用对象"><a href="#GROUP-BY-细化聚集函数的作用对象" class="headerlink" title="GROUP BY(细化聚集函数的作用对象)"></a>GROUP BY(细化聚集函数的作用对象)</h3><ul><li>将查询结果根据指定属性分组（可以是多个），值相等的为一组<ul><li>细化聚集函数的作用对象</li><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将作用于每个组</li></ul></li><li><strong>NOTE</strong>：有GROUP BY的查询中出现的属性必须属于(否则会报错)<ul><li>按GROUP BY分组的属性</li><li>聚集函数结果</li></ul></li><li>HAVING<ul><li>分组后要按一定条件对每一组分别筛选，最终只输出满足指定条件的组</li><li>与where的区别（作用对象不同）<ul><li>HAVING对分组之后的 <strong>每一组做筛选</strong>，条件作用于GROUP BY之后的每一组</li><li>WHERE作用于基本表或视图，选择满足条件的元组</li><li>WHERE子句 <strong>不能用聚集函数作为条件表达式</strong></li></ul></li></ul></li></ul><h3 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h3><ul><li>可以按一个或多个属性列排序<ul><li>升序：ASC（缺省值为升序）</li><li>降序：DESC</li></ul></li><li>对于空值排序时显示的次序由具体系统实现决定</li><li>例：查询选修3号课程的学生的学号及其程序，查询结果按分数降序排列<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno =<span class="string">'3'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><ul><li>包括等值与非等值连接查询，自然连接查询，自身连接查询，外连接查询，复合条件连接查询</li><li>WHERE子句中用来连接两个表的条件称为 <strong>连接条件</strong>或<strong>连接谓词</strong><ul><li>[table1]\<column1>&lt;比较运算符&gt;[table2]\<column2></column2></column1></li><li>比较运算符：=，&lt;，&gt;，&gt;=, &lt;=, !=</li><li>column称为 <strong>连接字段</strong>，<ul><li>连接条件中的各连接字段必须可比的，名字不必相同 </li></ul></li></ul></li><li>一条SQL语句可以同时完成选择和连接查询，WHERE子句是由<strong>连接谓词和选择谓词组成的复合条件</strong></li></ul><h3 id="等值与非等值连接查询"><a href="#等值与非等值连接查询" class="headerlink" title="等值与非等值连接查询"></a>等值与非等值连接查询</h3><ul><li><p>等值连接（连接运算符为=）</p><ul><li><p><strong>例</strong>:查询每个学生及其选修课程的情况</p><ul><li>连接Student与SC这两个表，其联系是通过公共属性Sno实现的</li><li>本例中，SELECT与WHERE子句中的属性名前都加上了 <strong>表名前缀</strong>，为了避免混淆</li><li>如果属性名只出现在其中一个连接表中，可以省略表名前缀<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.*, SC.*</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno = SC.Sno</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若去掉等值条件，结果为笛卡尔积</p></li><li>执行过程：嵌套循环法<ul><li>以两表连接为例：遍历第一个表，对于第一个表中的每一个元组，在第二个表中遍历匹配，如果满足连接条件，将两个表中的元组拼接起来，依次进行直到表1中的全部元组都处理完。</li><li>复杂度O(N²)</li><li>快速查找：索引</li></ul></li></ul></li><li>非等值连接（连接运算符不为等号）</li><li>若在等值连接中把目标列中重复的属性列去掉则为 <strong>自然连接</strong></li></ul><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><ul><li><p><strong>例</strong>：查询所有课程的间接先修课（即先修课的先修课）</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST.Cno,SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno =SECOND.Cno</span><br></pre></td></tr></table></figure></li><li><p>需要给表起 <strong>别名</strong> 以示区别，上例中Course表有FIRST和SECOND两个别名</p></li><li>由于所有属性名都是同表属性，因此相同属性名使用 <strong>别名前缀</strong></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul><li>外连接与普通连接区别<ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以 <strong>指定表为连接主体</strong>，将主题表中不满足连接条件的元组一并输出，若是在另一张表中没有符合连接条件，其另一张表属性值则填 <strong>空值NULL</strong></li></ul></li><li>左外连接<ul><li>列出左边关系中所有元组</li><li>T1 LEFT OUT JOIN T2 ON &lt;连接条件&gt;</li></ul></li><li>右外连接<ul><li>列出右边关系中所有元组</li><li>T1 RIGHT OUT JOIN T2 ON &lt;连接条件&gt;</li></ul></li><li>T1 JOIN T2 ON &lt;连接条件&gt;<ul><li>简单的等值连接的另一种写法</li></ul></li></ul><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><ul><li><p><strong>例</strong>：查询每个学生的学号、姓名、选秀的课程名及成绩</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.Sno，Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> S, SC, C</span><br><span class="line"><span class="keyword">WHERE</span> S.Sno=SC.Sno <span class="keyword">AND</span> C.Cno=SC.Cno</span><br></pre></td></tr></table></figure></li><li><p>关系数据库在执行多表连接时，先进行两个表的连接，再将中间结果与第三个表进行，通常会根据表具体信息进行 <strong>优化</strong></p></li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><ul><li><strong>一个SELECT-FROM-WHERE语句成为一个查询块</strong></li><li>将一个查询块的WHERE子句或HAVING短语的条件中的查询称为<strong>嵌套查询</strong></li><li><p><strong>例子</strong>：查询选修了2号课程的学生姓名</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">From</span> Studeng</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> </span><br><span class="line">    (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure></li><li><p>SQL语言允许多层嵌套查询</p></li><li><strong>子查询不能使用 ORDER BY子句</strong></li></ul><h3 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h3><ul><li>由于嵌套查询的的子查询结果往往是一个集合，所以嵌套查询中最常用IN作为谓词</li><li>方法：先分步完成查询，然后再构造嵌套查询</li><li><p><strong>例</strong>：查询与刘晨在同一个系学习的学生</p><ul><li><p>先确定刘晨所在系名</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span></span><br></pre></td></tr></table></figure></li><li><p>查找所有（CS）系学习的学生</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sdept <span class="keyword">From</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span></span><br></pre></td></tr></table></figure></li><li><p>将第一部查询结果放到第二步where查询中，构造嵌套查询</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sdept <span class="keyword">From</span> Student <span class="keyword">Where</span> Sdept <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> Sdept <span class="keyword">From</span> Student <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>)</span><br></pre></td></tr></table></figure></li><li><p>本例中的查询也可以通过自身连接完成</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S1.Sno,S1.Sname,S1.Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student S1,Student S2</span><br><span class="line"><span class="keyword">WHERE</span> S1.Sdept=S2.Sdept <span class="keyword">AND</span> S2.Sname=<span class="string">'刘晨'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>例</strong>：查询选修了课程名为‘信息系统’的学号和姓名</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">In</span></span><br><span class="line">    (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno <span class="keyword">In</span></span><br><span class="line">        (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> Cname=<span class="string">'信息系统'</span>))</span><br></pre></td></tr></table></figure><ul><li>本例可以用多表连接来实现</li></ul></li><li><strong>NOTE</strong>：有些嵌套查询可以用连接运算替代，有些不可以</li></ul><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><ul><li>当用户能确切知道内层查询返回的是单个值时，可以用比较运算符。</li><li><p><strong>例</strong>：找出每个学生超过他自己选修课程平均成绩的课程号(相关子查询)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno </span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade &gt;=(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade)</span><br><span class="line">                <span class="keyword">FROM</span> SC y</span><br><span class="line">                <span class="keyword">WHERE</span> y.Sno=x.Sno)</span><br></pre></td></tr></table></figure><ul><li>或者用表连接实现  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> First.Sno, First.Cno</span><br><span class="line"><span class="keyword">FROM</span> SC <span class="keyword">FIRST</span> </span><br><span class="line"><span class="keyword">JOIN</span>    </span><br><span class="line">(<span class="keyword">SELECT</span> Sno,(<span class="keyword">AVG</span>(Grade)<span class="keyword">as</span> AGrade) </span><br><span class="line"><span class="keyword">FROM</span> SC <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno)</span><br><span class="line">SA </span><br><span class="line"><span class="keyword">ON</span>(First.Sno=SA.Sno)</span><br><span class="line"><span class="keyword">WHERE</span> First.Grade &gt; SA.AGrade</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h3><ul><li>使用ANY或ALL谓词时则必须同时使用比较运算符</li><li>类似全称量词与存在量词</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwdsesez3dj30fo09jdgm.jpg" alt=""></li><li><p><strong>例</strong>：查询非计算机科学系比计算机科学系任意一个学生年龄小的学生姓名和年龄</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage <span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">Where</span> Sage &lt; <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                <span class="keyword">FROM</span> Student</span><br><span class="line">                <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept &lt;&gt;<span class="string">'CS'</span></span><br></pre></td></tr></table></figure><ul><li>也可以用聚集函数来实现  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt; </span><br><span class="line">            (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(Sage)</span><br><span class="line">            <span class="keyword">FROM</span> Student </span><br><span class="line">            <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept&lt;&gt;<span class="string">'CS'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在上例中若是条件改成<code>所有</code>则谓词改为ALL，聚集函数改为MIN</p></li><li>事实上，用聚集函数实现子查询比用ANY或ALL谓词查询效率要高，其对应关系如下<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fwdsg89vpyj30n904774h.jpg" alt=""></li></ul></li></ul><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><ul><li>代表存在量词 $\exists$</li><li><p>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑值true或false</p><ul><li><strong>例</strong>：查询所有选修了一号课程的学生名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">WHERE</span> Sno=Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>与EXISTS谓词相对应的是NOT EXISTS谓词，若内层查询结果为空，则外层的WHERE子句返回真值，否则返回false</p><ul><li><strong>例</strong>：查询所有没有选修一号课程的学生名</li></ul></li><li>带有IN谓词、比较运算符、ANY、ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换<ul><li><strong>例</strong>：查询与刘晨在同一个系上课的学生  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student S1 </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> </span><br><span class="line">    (<span class="keyword">SELECT</span>*</span><br><span class="line">    <span class="keyword">FROM</span> Student s2</span><br><span class="line">    <span class="keyword">WHERE</span> S2.Sdept=S1.Sdept <span class="keyword">AND</span> S2.Sname=<span class="string">'刘晨'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="量词的等价代换"><a href="#量词的等价代换" class="headerlink" title="量词的等价代换"></a>量词的等价代换</h4><ul><li>SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的逻辑</li><li>$(\forall x)P\equiv\neg(\exists x(\neg P))$</li><li><p><strong>例</strong>：查询选修了全部课程的学生姓名</p><ul><li>转换成：查询学生——没有一门课程是他不选修的。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span>*</span><br><span class="line">    <span class="keyword">FROM</span> Course</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span>*</span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">WHERE</span> Sno=Student.Sno</span><br><span class="line">        <span class="keyword">AND</span> Cno=Course.Cno))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>例</strong>：查询至少选修了学生201215122选修的全部课程的学生号码</p><ul><li>本查询可以用 <strong>逻辑蕴含</strong>来表达：查询学号为x的学生，对所有的课程y，只要201215122学生选修了课程y，则x也选修了y</li><li>$(\forall y)p\rightarrow q\equiv (\exists y(\neg(p\rightarrow q)))\equiv \neg(\exists(\exists p\bigvee q))\equiv \neg\exists y(p\bigwedge\neq q)$<ul><li>p表示谓词学生201215122选修了课程y</li><li>q表示谓词学生x选修了课程y</li></ul></li><li>通过量词转换，它表达的语义为<ul><li>不存在这样的课程，学生201215122选修了y，而学生x没有选</li></ul></li><li>SQL表示  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SC y</span><br><span class="line">     <span class="keyword">WHERE</span> y.Sno=<span class="string">'201215122'</span> <span class="keyword">AND</span></span><br><span class="line">     <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SElECT</span>* <span class="keyword">FROM</span> SC z</span><br><span class="line">         <span class="keyword">WHERE</span> z.Sno=x.Sno <span class="keyword">AND</span></span><br><span class="line">         z.Cno=y.Cno));</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h3><ul><li>子查询的查询条件不依赖于父查询。</li><li>先执行子查询，其查询结果用于建立父查询的查找条件</li><li>如前面介绍的带有IN谓词的子查询中的两个例子，就是不相关子查询</li></ul><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><ul><li>子查询的查询条件依赖于父查询 </li><li>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。</li><li>因此要先做父查询，对于每一个结果执行子查询，再进行父查询的查找</li><li>如以下的例子中就是相关子查询<ul><li>带有EXISTS谓词的子查询</li><li>比较运算符</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DBMS </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 下库文件的构建与使用</title>
      <link href="/posts/29892674/"/>
      <url>/posts/29892674/</url>
      <content type="html"><![CDATA[<h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><ul><li>在linux中，以.a为后缀，程序从静态库中直接拷贝函数到二进制映像文件</li><li>静态编译，没词静态库更新修改时，需要将应用程序重新编译</li></ul><a id="more"></a><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>生成目标文件<ul><li>gcc -c static_file.c(要构建的库文件源文件)<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41uk3yr1j30e902kt8t.jpg" alt=""></li></ul></li></ul></li><li>使用ar命令创建静态库<ul><li>ar rc static_file.a staticfile.o<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41v5v01nj30am02hmx7.jpg" alt=""></li></ul></li><li>可以使用 file <filename> 查看文件信息以及类型<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41vizs9zj308501iglj.jpg" alt=""></li></ul></filename></li></ul></li></ul><h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><ul><li>头文件和库文件信息<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41wpcsa3j30k306it9c.jpg" alt=""></li></ul></li><li>测试文件引用静态库头文件<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41xwamkvj30j606mmxm.jpg" alt=""></li></ul></li><li>编译 运行<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41yq956ej30ii02wweq.jpg" alt=""></li></ul></li></ul><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><ul><li>可执行文件在开始运行时将函数代码从共享库文件中读出。从而间接引用</li><li>在linux中，以libxxx.so.x.x为格式命名。</li><li>节省内存，多个引用共享</li></ul><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><ul><li>gcc 和-fPIC参数将源代码编译成.o的目标代码，这个选项生成的代码与位置无关，可以在任何地址被连接和装载<ul><li>其中lib.c为将要创建为库的函数实现代码<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw429597klj30cb04gq3a.jpg" alt=""></li></ul></li><li>使用-shared的选项生成共享库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42d3s3wcj30lg04lwf9.jpg" alt=""></li><li><code>-shared</code>参数用来编译构建共享库，</li><li><code>Wl</code>参数用来将后面的soname,libhello.so.1.0传递给共享库，</li><li>使用<code>-soname,libhello.so.1.0</code>来说明其soname为<code>libhello.so</code>，版本为1.0，其目标名为<code>libhello.so.1.0</code></li><li><code>-o</code>用来指定目标文件</li><li><code>-l</code>意思是引用C库</li></ul></li><li>创建soname连接<ul><li>前面定义的soname为<code>libhello.so</code>，因此需要创建一个<code>libhello.so</code>到<code>libhello.so.1.0</code>的连接<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42ifu84gj30fy02t3ys.jpg" alt=""></li></ul></li></ul></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>准备文件<ul><li>头文件libxxx.h<ul><li>知道有哪些函数，完成怎样的功能，返回值以及参数情况</li></ul></li><li>库文件libxxx.so.xx及其链接libxxx.so:库函数的二进制代码位置</li></ul></li><li>编译连接<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42mwlf0nj30l1020dg2.jpg" alt=""></li><li>使用lld命令查看此可执行程序使用了哪些共享库</li></ul></li><li>运行<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42qofqmaj30oj01rq35.jpg" alt=""></li><li>如果希望在使用连接器时不适用-Ldirectory标识就可以查我找到该库，则可以采用以下方式<ul><li>把此库拷贝到/usr/lib或者/lib文件夹中，或者在此两个文件夹任意一个中创建一个到该库的快捷方式，并命名为libname.so。</li><li>如果库所在路径没有在/usr/lib和/lib文件夹下，需要将该路径添加到文件<code>/etc/ld.so.conf</code>中，每一行增加一个路径，完成以上设置后，然后运行ldconfig命令更新库信息</li></ul></li></ul></li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><ul><li>Dynamically loaded Libraries(DLL)动态加载库是程序运行时在指定位置时刻可以加载的函数库</li><li>在linux中，动态库文件格式跟共享库没有区别，但是共享库是在运行时加载</li></ul><h3 id="有专门的一组API"><a href="#有专门的一组API" class="headerlink" title="有专门的一组API"></a>有专门的一组API</h3><ul><li>头文件 <code>dlfcn.h</code></li><li>打开动态库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42xehz8pj30x309yq9y.jpg" alt=""></li></ul></li><li>处理出错<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42y6b68ij30tw030dhd.jpg" alt=""></li></ul></li><li>查找符号 <ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42yrtn22j30x7033mzg.jpg" alt=""></li></ul></li><li>关闭动态库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42zd4rx7j30zc030402.jpg" alt=""></li></ul></li></ul><h2 id="库的基本路径"><a href="#库的基本路径" class="headerlink" title="库的基本路径"></a>库的基本路径</h2><ul><li>/lib<ul><li>标准共享库和静态库</li></ul></li><li>/usr/lib<ul><li>标准共享库和静态库</li></ul></li><li>/usr/local/lib<ul><li>本地函数库</li></ul></li></ul><h2 id="库文件搜索顺序"><a href="#库文件搜索顺序" class="headerlink" title="库文件搜索顺序"></a>库文件搜索顺序</h2><ul><li>首先在“LD_LIBRARY_PATH”环境变量所设置的路径下查找<ul><li>一般都没有赋值</li></ul></li><li>搜索动态装载器在/etc目录下的缓存文件/etc/ls.so.cache<ul><li>此文件在命令<code>ldconfig</code>创建更新</li><li>如果要使用自己创建的共享库文件（静态库直接在编译时指定），则需要将共享库拷贝到搜索路径下或指定该库的具体路径</li></ul></li><li>ldd<ul><li>查看某可执行程序共享库清单</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> SoftwareEngineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SoftwareEngineering </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Distribution Functions</title>
      <link href="/posts/152544101/"/>
      <url>/posts/152544101/</url>
      <content type="html"><![CDATA[<h1 id="Discrete-Distribution"><a href="#Discrete-Distribution" class="headerlink" title="Discrete Distribution"></a>Discrete Distribution</h1><h2 id="Binomial-Distribution"><a href="#Binomial-Distribution" class="headerlink" title="Binomial Distribution"></a>Binomial Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>\dbinom{n}{p}p^{k}(1-p)^{n-k},&amp; for\ k=0,1,\dots,n \cr 0, &amp; otherwise.\end{cases}$</li></ul><a id="more"></a><h2 id="Geometric-Distribution"><a href="#Geometric-Distribution" class="headerlink" title="Geometric Distribution"></a>Geometric Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>p(1-p)^{k-1},&amp; for\ k=1,2,3,\dots\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Negative-Binomial-Distribution"><a href="#Negative-Binomial-Distribution" class="headerlink" title="Negative Binomial Distribution"></a>Negative Binomial Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>\tbinom{k-1}{r-1}p^{r}(1-p)^{k-r}, &amp;for\ k=1,2,3\dots\cr 0&amp;otherwise.\end{cases}$</li></ul><h2 id="Hypergeometric-Distribution"><a href="#Hypergeometric-Distribution" class="headerlink" title="Hypergeometric Distribution"></a>Hypergeometric Distribution</h2><ul><li>$f_{X}(k) = P(X=k)=\begin{cases}<br>\frac{\tbinom{r}{k}\tbinom{n-r}{m-k}}{\tbinom{n}{m}} &amp;for\ 0\leq k\leq r\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Possion-Distribution"><a href="#Possion-Distribution" class="headerlink" title="Possion Distribution"></a>Possion Distribution</h2><ul><li>$P(X=k)=\frac{\lambda^{k}}{k!}e^{-\lambda},\quad k=0,1,2\dots$</li><li>Note that the Possion distribution can be derived as the <strong>limit of a binomial distribution</strong></li></ul><h1 id="Continuous-Distribution"><a href="#Continuous-Distribution" class="headerlink" title="Continuous Distribution"></a>Continuous Distribution</h1><h2 id="Uniform-Distribution"><a href="#Uniform-Distribution" class="headerlink" title="Uniform Distribution"></a>Uniform Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\frac{1}{b-a} &amp;for\ a\leq x\leq b\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Exponential-Distribution"><a href="#Exponential-Distribution" class="headerlink" title="Exponential Distribution"></a>Exponential Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\lambda e^{-\lambda x}, &amp;for\ x\geq 0\cr 0 &amp;otherwize.\end{cases}$</li><li>often used to model <strong>lifetimes or waiting times</strong></li></ul><h2 id="Normal-Distribution"><a href="#Normal-Distribution" class="headerlink" title="Normal Distribution"></a>Normal Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\frac{1}{\sigma\sqrt{2\pi}}e^{-(x-\mu)^{2}/(2\sigma^{2})} &amp;for\ t\geq 0\cr 0 &amp;otherwise.\end{cases}$</li><li>$\mu$:mean</li><li>$\sigma$:standard deviation</li><li>Properties<ul><li>$X\sim N(\mu,\sigma^{2})$ and $Y=aX+b$, then $Y\sim N(a\mu+b,a^{2}\sigma^{2})$</li><li>Nornalization:$X\sim N(\mu,\sigma^{2})$, then $Z=\frac{X-\mu}{\sigma}\sim N(0,1)$</li></ul></li></ul><h2 id="Gamma-Distribution"><a href="#Gamma-Distribution" class="headerlink" title="Gamma Distribution"></a>Gamma Distribution</h2><ul><li>$g(t)=\begin{cases}\frac{\lambda^{\alpha}}{\Gamma(\alpha)}t^{\alpha-1}e^{-\lambda t},&amp;for\ t\geq 0\cr 0,&amp;otherwise.\end{cases}$<ul><li>$\Gamma(x)=\int^{\infty}_{0}u^{x-1}e^{u}dt,x&gt;0$</li><li>if a=1 the gamma density coincides with the exponential density</li><li>$\alpha$:shape parameter</li><li>$\lambda$:scale parameter</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Mathematical Statistics and DataAnalysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis设计与实现之数据结构</title>
      <link href="/posts/499093544/"/>
      <url>/posts/499093544/</url>
      <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>内置集合数据类型，支持集合操作</li><li>Redis的字符串数据类型既可以存储字符串，又可以存储整数和浮点数，甚至是二进制位</li><li>Redis的一部分命令只能对特定数据类型执行，另一部分命令却可以对所有数据类型执行。</li></ul><a id="more"></a><h2 id="Redis-对象"><a href="#Redis-对象" class="headerlink" title="Redis 对象"></a>Redis 对象</h2><ul><li>Redis数据库里面的每个键值对(key-value pair)都是由对象(object)组成的<ul><li>数据库键总是一个字符串对象(string object)</li><li>数据库键的值则可以是<ul><li>字符串对象</li><li>列表对象</li><li>哈希对象</li><li>集合对象</li><li>有序集合对象</li></ul></li></ul></li></ul><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><ul><li>Redis 没有直接使用c语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（SDS）的抽象类型。</li><li>Redis里的c字符串字作为<code>string literal</code>用在对字符串不修改的地方</li><li>SDS除了用来保存字符串值，SDS还被用作缓冲区（buffer）</li><li>SDS定义（sdshdr结构体）<ul><li>int len<ul><li>buf数组中已使用字节的数量，等于SCS所保存字符串的长度</li><li>SDS中的空字符不计算在SDS的len属性里</li><li>空字符对于SDS的使用者完全透明</li></ul></li><li>int free<ul><li>buf数据中未使用字节的数量</li></ul></li><li>char buf[]<ul><li>字节数组，保存字符串</li></ul></li></ul></li><li><p>SDS与C字符串的区别</p><ul><li>SDS以常数复杂度获取字符串长度<ul><li>C字符串并不记录自身长度信息，为了获取C字符串的长度必须遍历整个字符串，复杂度为O(N)</li><li>SDS中只要访问其<code>len</code>属性得到其长度。</li><li>设置和更新SDS长度的工作是由SDS API在执行时自动完成的。</li></ul></li><li><p>杜绝缓冲区溢出（buffer overflow）</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br></pre></td></tr></table></figure></li><li><p>由于C字符串不记录自身长度所以<code>strcat</code>假定用户已经为<code>dest</code>分配足够多内存足够容纳<code>src</code>中的所有内容，易产生缓冲区溢出</p></li><li>当SDS API需要对SDS进行修改时，API会先检查SDS空间是否满足要求，若不满足，则自动将SDS空间扩展到执行修改所需的大小。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">"Cluster"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>减少修改字符串时带来的内存重分配次数</p><ul><li>每次修改C字符串，程序总要对保存这个c字符串的数组进行一次内存重分配操作<ul><li>增长字符串如<code>append</code>：<ul><li>检查并通过内存重分配扩展底层数组空间大小</li></ul></li><li>缩短字符串<code>trim</code>，执行操作后要通过内存重分配释放字符串空余的空间，以防内存泄漏</li></ul></li><li>内存重分配设计复杂算法，且可能需要执行系统调用，所以通常比较耗时</li><li>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量len加一，可以包含free属性记录的SDS未使用字节数量。<ul><li>空间预分配<ul><li>当SDS对空间进行扩展时，程序不仅会对SDS分配修改所必要的空间，还会对SDS分配额外的未使用空间：分为两种情况（避免分配太多未使用空间）<ul><li>当修改之后SDS长度小于1MB，那么程序分配和len属性同样大小的未使用空间。</li><li>若修改之后SDS长度大于1MB，那么程序只分配1MB的未使用空间</li></ul></li><li>通过预分配策略，Redis可以减少连续执行内存重分配次数。</li></ul></li><li>惰性空间释放<ul><li>当SDS的API需要缩短SDS保存的字符串时，并不立即回收缩短后多出来的字节，而是使用<code>free</code>属性将这些字节的数量记录起来，等待将来使用(overwrite)</li></ul></li></ul></li></ul></li><li>二进制安全 <ul><li>C字符串中的字符必须符合某种编码（ASCII），使得C字符串只能保存文本数据，而不能保存图片、音频、视频、等二进制数据。如：无法使用空字符来分割单词的特殊数据格式</li><li>SDS的API都是二进制安全的，都会以处理二进制的方式来处理SDS存放在buf数组里的数据。</li></ul></li><li>兼容部分C字符串函数<ul><li>这些API将SDS保存的数据的末尾设置为空字符，在buf分配空间时多分配一个字节容纳空字符，这是为了让保存文本数据的SDS可以重用一部分<string.h>库定义的函数。<ul><li>重用strcasecmp，对比SDS字符串和另一个字符串</li><li>利用strcat，将SDS字符串追加到C字符串之后。</li></ul></string.h></li></ul></li></ul></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>提供了高效的节点重排能力，以及顺序性的节点访问方式，可以通过增删节点来灵活的调整链表的长度</li><li>应用：<ul><li>当一个链表键包含了数量比较多的元素又或者列表中的元素都是比较长的字符串时，Redis使用链表作为底层实现。</li><li>发布与订阅、慢查询、监视器等功能</li><li>Redis本身使用链表保存多个客户端状态信息。</li></ul></li><li>链表和链表节点<ul><li>adlist.h/listNode<ul><li>listNode *prev</li><li>listNode *next</li><li>void *value</li></ul></li><li>多个listNode可以通过前后指针组成双端链表</li><li>adlist.h/list<ul><li>listNode *head</li><li>listNode *tail</li><li>unsigned long len(节点数量)</li><li>void <em>(</em>dup)(void *ptr)(节点值复制)</li><li>void (<em>free)(void </em>ptr)(节点值释放)</li><li>int (<em>match)(void </em>ptr,void *key)(节点值对比)</li></ul></li><li>成员函数用于实现多态链表</li></ul></li><li>Redis链表特性<ul><li>双端</li><li>无环</li><li>带表头指针和表尾指针</li><li>表长度计数器</li><li>多态 链表节点使用void*指针来保存节点值，所以链表可以用于保存各种不同类型的值。</li></ul></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>一种用于保存键值对(key-value pair)的抽象数据结构</li><li>Redis的数据库就是使用字典来作为底层实现，对数据库的CRUD操作也是构建在对字典的操作之上。</li><li>字典还是哈希键的底层实现之一，当哈希键包含的键值对比较多，或者键值对中的元素比较长的字符串时，Redis使用字典作为hash键的底层实现。</li></ul><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><ul><li>hash表<ul><li>dict.h/dictht<ul><li>dictEntry **table<ul><li>哈希表数组</li><li>每一个dictEntry结构保存着一个键值对</li></ul></li><li>unsigned long size<ul><li>哈希表大小</li></ul></li><li>unsigned long sizemask<ul><li>哈希表大小掩码，用于计算索引值，总是等于size-1</li></ul></li><li>unsigned long used<ul><li>哈希表已有的节点的数量</li></ul></li></ul></li></ul></li><li>hash表节点<ul><li>dict.h/dictEntry<ul><li>void* key<ul><li>键</li></ul></li><li>union{void *val;uint64_tu64; int64_ts64} v;<ul><li>值</li></ul></li><li>struct dictEntry *next<ul><li>指向下个哈希表节点，形成链表</li><li>可以将多个哈希值相同的键值连接在一起，以此来解决键冲突问题。</li></ul></li></ul></li></ul></li><li>字典<ul><li>dict.h/dict<ul><li>dictType *type<ul><li>类型特定函数</li><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为用途不同的字典设置不同的特定类型函数<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzx8sofgdj30qa0ffq6e.jpg" alt=""></li></ul></li></ul></li><li>void *privdata<ul><li>私有数据</li></ul></li><li>dictht ht[2]<ul><li>哈希表</li></ul></li><li>int rehashidx<ul><li>rehash索引</li><li>当rehash不在进行时，值为-1</li></ul></li></ul></li><li>Hash算法<ul><li>使用字典设置的hash函数，计算key的hash值<ul><li>Redis使用MurmurHash2算法来计算键的哈希值</li></ul></li><li>使用哈希表的sizemask属性和哈希值，计算出索引值<ul><li>根据情况，ht[x]可以是ht[0]或ht[1]</li></ul></li></ul></li><li>解决键冲突<ul><li>Redis哈希表使用链地址法来解决键冲突<ul><li>因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，总是将新节点添加到表头位置</li></ul></li></ul></li><li>rehash<ul><li>哈希表中保存的键值会逐渐增多或减少，为了让哈希表的 <strong>负载因子</strong>(load factor)维持在一个合理的范围之内，程序需要对哈希表的大小进行相应的扩展或者收缩，通过执行<code>rehash</code>操作来完成<ul><li>为字典的<code>ht[1]</code>哈希表分配空间<ul><li>大小取决于ht[0]当前包含的键值对数量</li><li>以及要执行的操作<ul><li>若是扩展操作，则ht[1]大小为ht[0].used*2</li><li>若是收缩操作，则ht[1]大小为第一个大于等于ht[0].used的2的n次幂</li></ul></li></ul></li><li>将所有ht[0]中的键值对rehash到ht[1]上</li><li>释放ht[0]，将ht[1]设置为ht[0]，并为ht[1]新创建一个空白hashtable，为下一次rehash做准备</li></ul></li></ul></li><li>表的扩展与收缩<ul><li>扩展<ul><li>服务器目前没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>，并且load factor 大于等于1</li><li>服务器目前执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>，并且load factor 大于等于5</li><li>根据是否执行BGSAVE和BGREWRITEAOF，扩展所需的负载因子并不相同<ul><li>在执行上述两命令时，Redis需要创建服务器进程子进程，而大多数操作系统都采用 <strong>写时复制</strong> 来优化子进程使用效率，所以在子进程存在期间服务器提高负载因子阈值。</li></ul></li></ul></li><li>收缩<ul><li>当load factor小于0.1时，开始收缩操作</li></ul></li></ul></li><li>渐进式rehash<ul><li>如果哈希表中过多键值对，在rehash到ht[1]时可能会导致服务器在一段时期停止服务</li><li>因此，为了避免rehash对服务器性能有影响，rehash是分多次、渐进式进行的<ul><li>为ht[1]分配空间</li><li>字典中维持一个索引计数器变量<code>rehashidx</code>,初始值为0</li><li>rehash期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，rehashidx递增</li><li>随着字典操作不断执行，ht[0]最终全部被rehash，这时将rehashidx属性值设为-1，表示rehash已经完成</li></ul></li></ul></li><li>在渐进式rehash进行期间，对ht[0]的RUD操作，会在两个哈希表上进行<ul><li>查找键，现在ht[0]查找，否则在ht[1]上找</li><li>插入的键保存到ht[1]中，ht[0]不在进行任何添加操作</li></ul></li><li>字典API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzyhmpjybj30k606ijt4.jpg" alt=""></li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzyi7zsg2j30je02tq3n.jpg" alt=""></li></ul></li></ul></li></ul><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><ul><li>整数集合(intset)是集合键的底层实现之一<ul><li>当一个集合只包含整数值元素且元素数量不多时，Redis使用整数集合作为集合键的底层实现</li></ul></li><li>实现<ul><li>可以保存类型为int16_t、int32_t、int64_t</li><li>intset.h/intset<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzypl9z33j305z04r0sy.jpg" alt=""></li><li><code>contents</code>数组是整数集合的实现，每个项在数组中按值递增有序排列，且不包含任何重复项</li><li><code>length</code>记录了集合元素数量，也即contents数组长度</li><li>intset的contents数组并不保存任何int8_t类型的值，contents数组真正类型取决于encoding属性的值<ul><li>INTEST_ENC_INT16—&gt;int16_t</li><li>INTSET_ENC_INT32—&gt;int32_t</li><li>INTSET_ENC_INT64—&gt;int64_t</li></ul></li></ul></li></ul></li><li>升级<ul><li>当要讲一个新元素添加到整数集合里面，并且新元素的类型比整数集合元素类型都要长时，整数集合需要先进行升级<ul><li>根据新元素类型，扩展整数集合底层数组空间大小，并为新元素分配空间</li><li>将底层现有的所有元素都转换成与新元素相同的类型，在放置元素在正确位置的过程中，保证有序性</li><li>将新元素添加到底层数组里面</li></ul></li><li>升级的好处<ul><li>提升整数集合的灵活性<ul><li>随意将不同长度的整形数添加到集合中，而不必担心出现类型错误</li></ul></li><li>尽可能的节约内存<ul><li>不是直接用int64_t单元数组作为底层实现，而是只在需要的时候才扩展空间进行升级，可以尽量节省内存</li></ul></li></ul></li></ul></li><li>降级<ul><li>Redis整数集合不支持降级操作，编码一直保持升级后的状态</li></ul></li><li>整数集合API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw00rs8nz3j30jg06pq5b.jpg" alt=""></li></ul></li></ul><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><ul><li>压缩列表是列表键和哈希键的底层实现之一<ul><li>列表键只包含少量列表项<ul><li>每个列表项是小整数值或长度较短的字符串</li></ul></li><li>哈希键只包含少量键值对<ul><li>每个键值对的键值是小整数值或长度比较短的字符串</li></ul></li></ul></li><li>压缩列表的构成<ul><li>为了节约内存而开发，是由一系列特殊编码的连续内存块组成的顺序性(sequential)数据结构。<ul><li>一个压缩列表包含任意多节点（entry），每个节点保存一个字节数组或者一个整数值</li></ul></li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0k0c92anj30j606dtbi.jpg" alt=""></li><li>每个压缩列表节点可以保存一个字节数组或者一个整数值<ul><li>字节数组<ul><li>长度小于2的6次幂-1字节</li><li>长度小于2的14次幂-1字节</li><li>长度小于2的32次幂-1字节</li></ul></li><li>整数值<ul><li>四位长，0~12之间的无符号整数</li><li>1字节的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t,int32_t,int64_t</li></ul></li><li>每个压缩列表节点<ul><li>previous_entry_length<ul><li>以字节为单位，记录前一个节点的长度</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0kmzomunj30i903at9y.jpg" alt=""></li><li>程序可以通过指针运算，根据当前节点的起始地址来计算前一个节点的起始地址</li><li>压缩列表从表尾向表头遍历操作就是这一原理实现</li></ul></li><li>encoding<ul><li>encoding属性记录了节点的content属性所保存数据的类型以及长度<ul><li>一字节、两字节或五字节长，值的最高位为00,01或者10的是 <strong>字节数组编码</strong><ul><li>表示节点的content属性保存字节数组，数组长度由编码除去最高两位之后的其它位记录</li></ul></li><li>一字节长，值的最高位以11开头的是 <strong>整数编码</strong><ul><li>content属性保存着整数值、整数值的类型和长度由编码除去最高两位之后的其他位记录</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0lki8wh6j30ja05gmyx.jpg" alt=""></li></ul></li></ul></li></ul></li><li>content<ul><li>负责保存节点的值</li></ul></li></ul></li></ul></li></ul></li><li>连锁更新<ul><li>假设一种情况（添加新节点）<ul><li>在一个压缩列表中，有多个连续的、长度介于250到253字节的节点<ul><li>因为e1到en的所有节点长度都小于254字节，所以只需要一字节长的previous_entry_length属性</li></ul></li><li>这是，如果将一个长度大于等于254字节的new节点插入到表头节点，那么new节点将成为e1前置节点</li><li>由于e1的previous_entry_length属性只有一字节，无法保存new节点的长度，因此对压缩列表执行 <strong>空间重分配操作</strong>，并将e1节点的previous_entry_length属性扩展到五字节</li><li>e1长度原本介于250到253字节，但经过previous_entry_length扩展字节后，长度超过254字节，为了让e2的previous_entry_length可以记录下e1节点的长度，再次进行空间重分配，将e2的previous_entry_length扩展到五字节</li><li>以此类推：扩展e1引发对e2扩展，同样引发对e3扩展…知道eN为止</li></ul></li><li>另一种情况（删除新节点）<ul><li>如果e1至eN都是长度介于250~253之间的节点，而e1之前的big(表头节点，大于254)和small节点（big之后，小于254）.</li><li>将small节点从压缩列表中删除之后，e1的previous_entry_length就从保存small长度变为保存big长度，因此需要重新分配空间，扩展precious_entry_length到5字节</li><li>e1长度经过扩展超过254字节，因此引发了后续的连锁扩展</li></ul></li><li>复杂度<ul><li>最坏情况下需要执行N次空间重分配操作，每次分配最坏复杂度为O(N)，所以每次连锁更新复杂度为O(N²)</li><li>虽然复杂度较高，但进行连锁更新的概率较低</li></ul></li></ul></li><li>压缩列表API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0lnr6xvsj30j10bwq76.jpg" alt=""></li><li><code>ziplistPush</code>、<code>ziplistInsert</code>、<code>ziplistDelete</code>、<code>ziplistDelete</code>都有可能引发连锁更新</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJ 1006 Biorhythms</title>
      <link href="/posts/2811150533/"/>
      <url>/posts/2811150533/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1006" target="_blank" rel="noopener">题目链接</a><br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目较易理解，大致思路就是寻找三个生理周期高峰出现在同一天的日期，除此之外题目中给了变量<code>d</code>，即相对于日期<code>d</code>的天数（当然，<code>d</code>可以小于三个周期的周期天数）。</p><h3 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h3><ul><li>最容易想到的就是遍历每一天，直到找到符合要求的为止，最大不超过<code>21252</code>(三个周期的最小公倍数)</li></ul><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3>]]></content>
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>test_my_site</title>
      <link href="/posts/1965421688/"/>
      <url>/posts/1965421688/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1243066710/"/>
      <url>/posts/1243066710/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
