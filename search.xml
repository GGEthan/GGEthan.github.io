<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux 下库文件的构建与使用</title>
      <link href="/posts/29892674/"/>
      <url>/posts/29892674/</url>
      <content type="html"><![CDATA[<h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><ul><li>在linux中，以.a为后缀，程序从静态库中直接拷贝函数到二进制映像文件</li><li>静态编译，没词静态库更新修改时，需要将应用程序重新编译</li></ul><a id="more"></a><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>生成目标文件<ul><li>gcc -c static_file.c(要构建的库文件源文件)<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41uk3yr1j30e902kt8t.jpg" alt=""></li></ul></li></ul></li><li>使用ar命令创建静态库<ul><li>ar rc static_file.a staticfile.o<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41v5v01nj30am02hmx7.jpg" alt=""></li></ul></li><li>可以使用 file <filename> 查看文件信息以及类型<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41vizs9zj308501iglj.jpg" alt=""></li></ul></filename></li></ul></li></ul><h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><ul><li>头文件和库文件信息<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41wpcsa3j30k306it9c.jpg" alt=""></li></ul></li><li>测试文件引用静态库头文件<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41xwamkvj30j606mmxm.jpg" alt=""></li></ul></li><li>编译 运行<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw41yq956ej30ii02wweq.jpg" alt=""></li></ul></li></ul><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><ul><li>可执行文件在开始运行时将函数代码从共享库文件中读出。从而间接引用</li><li>在linux中，以libxxx.so.x.x为格式命名。</li><li>节省内存，多个引用共享</li></ul><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><ul><li>gcc 和-fPIC参数将源代码编译成.o的目标代码，这个选项生成的代码与位置无关，可以在任何地址被连接和装载<ul><li>其中lib.c为将要创建为库的函数实现代码<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw429597klj30cb04gq3a.jpg" alt=""></li></ul></li><li>使用-shared的选项生成共享库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42d3s3wcj30lg04lwf9.jpg" alt=""></li><li><code>-shared</code>参数用来编译构建共享库，</li><li><code>Wl</code>参数用来将后面的soname,libhello.so.1.0传递给共享库，</li><li>使用<code>-soname,libhello.so.1.0</code>来说明其soname为<code>libhello.so</code>，版本为1.0，其目标名为<code>libhello.so.1.0</code></li><li><code>-o</code>用来指定目标文件</li><li><code>-l</code>意思是引用C库</li></ul></li><li>创建soname连接<ul><li>前面定义的soname为<code>libhello.so</code>，因此需要创建一个<code>libhello.so</code>到<code>libhello.so.1.0</code>的连接<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42ifu84gj30fy02t3ys.jpg" alt=""></li></ul></li></ul></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>准备文件<ul><li>头文件libxxx.h<ul><li>知道有哪些函数，完成怎样的功能，返回值以及参数情况</li></ul></li><li>库文件libxxx.so.xx及其链接libxxx.so:库函数的二进制代码位置</li></ul></li><li>编译连接<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42mwlf0nj30l1020dg2.jpg" alt=""></li><li>使用lld命令查看此可执行程序使用了哪些共享库</li></ul></li><li>运行<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42qofqmaj30oj01rq35.jpg" alt=""></li><li>如果希望在使用连接器时不适用-Ldirectory标识就可以查我找到该库，则可以采用以下方式<ul><li>把此库拷贝到/usr/lib或者/lib文件夹中，或者在此两个文件夹任意一个中创建一个到该库的快捷方式，并命名为libname.so。</li><li>如果库所在路径没有在/usr/lib和/lib文件夹下，需要将该路径添加到文件<code>/etc/ld.so.conf</code>中，每一行增加一个路径，完成以上设置后，然后运行ldconfig命令更新库信息</li></ul></li></ul></li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><ul><li>Dynamically loaded Libraries(DLL)动态加载库是程序运行时在指定位置时刻可以加载的函数库</li><li>在linux中，动态库文件格式跟共享库没有区别，但是共享库是在运行时加载</li></ul><h3 id="有专门的一组API"><a href="#有专门的一组API" class="headerlink" title="有专门的一组API"></a>有专门的一组API</h3><ul><li>头文件 <code>dlfcn.h</code></li><li>打开动态库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42xehz8pj30x309yq9y.jpg" alt=""></li></ul></li><li>处理出错<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42y6b68ij30tw030dhd.jpg" alt=""></li></ul></li><li>查找符号 <ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42yrtn22j30x7033mzg.jpg" alt=""></li></ul></li><li>关闭动态库<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw42zd4rx7j30zc030402.jpg" alt=""></li></ul></li></ul><h2 id="库的基本路径"><a href="#库的基本路径" class="headerlink" title="库的基本路径"></a>库的基本路径</h2><ul><li>/lib<ul><li>标准共享库和静态库</li></ul></li><li>/usr/lib<ul><li>标准共享库和静态库</li></ul></li><li>/usr/local/lib<ul><li>本地函数库</li></ul></li></ul><h2 id="库文件搜索顺序"><a href="#库文件搜索顺序" class="headerlink" title="库文件搜索顺序"></a>库文件搜索顺序</h2><ul><li>首先在“LD_LIBRARY_PATH”环境变量所设置的路径下查找<ul><li>一般都没有赋值</li></ul></li><li>搜索动态装载器在/etc目录下的缓存文件/etc/ls.so.cache<ul><li>此文件在命令<code>ldconfig</code>创建更新</li><li>如果要使用自己创建的共享库文件（静态库直接在编译时指定），则需要将共享库拷贝到搜索路径下或指定该库的具体路径</li></ul></li><li>ldd<ul><li>查看某可执行程序共享库清单</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> SoftwareEngineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SoftwareEngineering </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Distribution Functions</title>
      <link href="/posts/152544101/"/>
      <url>/posts/152544101/</url>
      <content type="html"><![CDATA[<h1 id="Discrete-Distribution"><a href="#Discrete-Distribution" class="headerlink" title="Discrete Distribution"></a>Discrete Distribution</h1><h2 id="Binomial-Distribution"><a href="#Binomial-Distribution" class="headerlink" title="Binomial Distribution"></a>Binomial Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>\dbinom{n}{p}p^{k}(1-p)^{n-k},&amp; for\ k=0,1,\dots,n \cr 0, &amp; otherwise.\end{cases}$</li></ul><a id="more"></a><h2 id="Geometric-Distribution"><a href="#Geometric-Distribution" class="headerlink" title="Geometric Distribution"></a>Geometric Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>p(1-p)^{k-1},&amp; for\ k=1,2,3,\dots\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Negative-Binomial-Distribution"><a href="#Negative-Binomial-Distribution" class="headerlink" title="Negative Binomial Distribution"></a>Negative Binomial Distribution</h2><ul><li>$f_{X}(k)=P(X=k)=\begin{cases}<br>\tbinom{k-1}{r-1}p^{r}(1-p)^{k-r}, &amp;for\ k=1,2,3\dots\cr 0&amp;otherwise.\end{cases}$</li></ul><h2 id="Hypergeometric-Distribution"><a href="#Hypergeometric-Distribution" class="headerlink" title="Hypergeometric Distribution"></a>Hypergeometric Distribution</h2><ul><li>$f_{X}(k) = P(X=k)=\begin{cases}<br>\frac{\tbinom{r}{k}\tbinom{n-r}{m-k}}{\tbinom{n}{m}} &amp;for\ 0\leq k\leq r\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Possion-Distribution"><a href="#Possion-Distribution" class="headerlink" title="Possion Distribution"></a>Possion Distribution</h2><ul><li>$P(X=k)=\frac{\lambda^{k}}{k!}e^{-\lambda},\quad k=0,1,2\dots$</li><li>Note that the Possion distribution can be derived as the <strong>limit of a binomial distribution</strong></li></ul><h1 id="Continuous-Distribution"><a href="#Continuous-Distribution" class="headerlink" title="Continuous Distribution"></a>Continuous Distribution</h1><h2 id="Uniform-Distribution"><a href="#Uniform-Distribution" class="headerlink" title="Uniform Distribution"></a>Uniform Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\frac{1}{b-a} &amp;for\ a\leq x\leq b\cr 0 &amp;otherwise.\end{cases}$</li></ul><h2 id="Exponential-Distribution"><a href="#Exponential-Distribution" class="headerlink" title="Exponential Distribution"></a>Exponential Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\lambda e^{-\lambda x}, &amp;for\ x\geq 0\cr 0 &amp;otherwize.\end{cases}$</li><li>often used to model <strong>lifetimes or waiting times</strong></li></ul><h2 id="Normal-Distribution"><a href="#Normal-Distribution" class="headerlink" title="Normal Distribution"></a>Normal Distribution</h2><ul><li>$f_{X}(x)=\begin{cases}<br>\frac{1}{\sigma\sqrt{2\pi}}e^{-(x-\mu)^{2}/(2\sigma^{2})} &amp;for\ t\geq 0\cr 0 &amp;otherwise.\end{cases}$</li><li>$\mu$:mean</li><li>$\sigma$:standard deviation</li><li>Properties<ul><li>$X\sim N(\mu,\sigma^{2})$ and $Y=aX+b$, then $Y\sim N(a\mu+b,a^{2}\sigma^{2})$</li><li>Nornalization:$X\sim N(\mu,\sigma^{2})$, then $Z=\frac{X-\mu}{\sigma}\sim N(0,1)$</li></ul></li></ul><h2 id="Gamma-Distribution"><a href="#Gamma-Distribution" class="headerlink" title="Gamma Distribution"></a>Gamma Distribution</h2><ul><li>$g(t)=\begin{cases}\frac{\lambda^{\alpha}}{\Gamma(\alpha)}t^{\alpha-1}e^{-\lambda t},&amp;for\ t\geq 0\cr 0,&amp;otherwise.\end{cases}$<ul><li>$\Gamma(x)=\int^{\infty}_{0}u^{x-1}e^{u}dt,x&gt;0$</li><li>if a=1 the gamma density coincides with the exponential density</li><li>$\alpha$:shape parameter</li><li>$\lambda$:scale parameter</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Mathematical Statistics and DataAnalysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis设计与实现之数据结构</title>
      <link href="/posts/499093544/"/>
      <url>/posts/499093544/</url>
      <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>内置集合数据类型，支持集合操作</li><li>Redis的字符串数据类型既可以存储字符串，又可以存储整数和浮点数，甚至是二进制位</li><li>Redis的一部分命令只能对特定数据类型执行，另一部分命令却可以对所有数据类型执行。</li></ul><a id="more"></a><h2 id="Redis-对象"><a href="#Redis-对象" class="headerlink" title="Redis 对象"></a>Redis 对象</h2><ul><li>Redis数据库里面的每个键值对(key-value pair)都是由对象(object)组成的<ul><li>数据库键总是一个字符串对象(string object)</li><li>数据库键的值则可以是<ul><li>字符串对象</li><li>列表对象</li><li>哈希对象</li><li>集合对象</li><li>有序集合对象</li></ul></li></ul></li></ul><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><ul><li>Redis 没有直接使用c语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（SDS）的抽象类型。</li><li>Redis里的c字符串字作为<code>string literal</code>用在对字符串不修改的地方</li><li>SDS除了用来保存字符串值，SDS还被用作缓冲区（buffer）</li><li>SDS定义（sdshdr结构体）<ul><li>int len<ul><li>buf数组中已使用字节的数量，等于SCS所保存字符串的长度</li><li>SDS中的空字符不计算在SDS的len属性里</li><li>空字符对于SDS的使用者完全透明</li></ul></li><li>int free<ul><li>buf数据中未使用字节的数量</li></ul></li><li>char buf[]<ul><li>字节数组，保存字符串</li></ul></li></ul></li><li><p>SDS与C字符串的区别</p><ul><li>SDS以常数复杂度获取字符串长度<ul><li>C字符串并不记录自身长度信息，为了获取C字符串的长度必须遍历整个字符串，复杂度为O(N)</li><li>SDS中只要访问其<code>len</code>属性得到其长度。</li><li>设置和更新SDS长度的工作是由SDS API在执行时自动完成的。</li></ul></li><li><p>杜绝缓冲区溢出（buffer overflow）</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br></pre></td></tr></table></figure></li><li><p>由于C字符串不记录自身长度所以<code>strcat</code>假定用户已经为<code>dest</code>分配足够多内存足够容纳<code>src</code>中的所有内容，易产生缓冲区溢出</p></li><li>当SDS API需要对SDS进行修改时，API会先检查SDS空间是否满足要求，若不满足，则自动将SDS空间扩展到执行修改所需的大小。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, <span class="string">"Cluster"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>减少修改字符串时带来的内存重分配次数</p><ul><li>每次修改C字符串，程序总要对保存这个c字符串的数组进行一次内存重分配操作<ul><li>增长字符串如<code>append</code>：<ul><li>检查并通过内存重分配扩展底层数组空间大小</li></ul></li><li>缩短字符串<code>trim</code>，执行操作后要通过内存重分配释放字符串空余的空间，以防内存泄漏</li></ul></li><li>内存重分配设计复杂算法，且可能需要执行系统调用，所以通常比较耗时</li><li>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf数组的长度不一定是字符数量len加一，可以包含free属性记录的SDS未使用字节数量。<ul><li>空间预分配<ul><li>当SDS对空间进行扩展时，程序不仅会对SDS分配修改所必要的空间，还会对SDS分配额外的未使用空间：分为两种情况（避免分配太多未使用空间）<ul><li>当修改之后SDS长度小于1MB，那么程序分配和len属性同样大小的未使用空间。</li><li>若修改之后SDS长度大于1MB，那么程序只分配1MB的未使用空间</li></ul></li><li>通过预分配策略，Redis可以减少连续执行内存重分配次数。</li></ul></li><li>惰性空间释放<ul><li>当SDS的API需要缩短SDS保存的字符串时，并不立即回收缩短后多出来的字节，而是使用<code>free</code>属性将这些字节的数量记录起来，等待将来使用(overwrite)</li></ul></li></ul></li></ul></li><li>二进制安全 <ul><li>C字符串中的字符必须符合某种编码（ASCII），使得C字符串只能保存文本数据，而不能保存图片、音频、视频、等二进制数据。如：无法使用空字符来分割单词的特殊数据格式</li><li>SDS的API都是二进制安全的，都会以处理二进制的方式来处理SDS存放在buf数组里的数据。</li></ul></li><li>兼容部分C字符串函数<ul><li>这些API将SDS保存的数据的末尾设置为空字符，在buf分配空间时多分配一个字节容纳空字符，这是为了让保存文本数据的SDS可以重用一部分<string.h>库定义的函数。<ul><li>重用strcasecmp，对比SDS字符串和另一个字符串</li><li>利用strcat，将SDS字符串追加到C字符串之后。</li></ul></string.h></li></ul></li></ul></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>提供了高效的节点重排能力，以及顺序性的节点访问方式，可以通过增删节点来灵活的调整链表的长度</li><li>应用：<ul><li>当一个链表键包含了数量比较多的元素又或者列表中的元素都是比较长的字符串时，Redis使用链表作为底层实现。</li><li>发布与订阅、慢查询、监视器等功能</li><li>Redis本身使用链表保存多个客户端状态信息。</li></ul></li><li>链表和链表节点<ul><li>adlist.h/listNode<ul><li>listNode *prev</li><li>listNode *next</li><li>void *value</li></ul></li><li>多个listNode可以通过前后指针组成双端链表</li><li>adlist.h/list<ul><li>listNode *head</li><li>listNode *tail</li><li>unsigned long len(节点数量)</li><li>void <em>(</em>dup)(void *ptr)(节点值复制)</li><li>void (<em>free)(void </em>ptr)(节点值释放)</li><li>int (<em>match)(void </em>ptr,void *key)(节点值对比)</li></ul></li><li>成员函数用于实现多态链表</li></ul></li><li>Redis链表特性<ul><li>双端</li><li>无环</li><li>带表头指针和表尾指针</li><li>表长度计数器</li><li>多态 链表节点使用void*指针来保存节点值，所以链表可以用于保存各种不同类型的值。</li></ul></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>一种用于保存键值对(key-value pair)的抽象数据结构</li><li>Redis的数据库就是使用字典来作为底层实现，对数据库的CRUD操作也是构建在对字典的操作之上。</li><li>字典还是哈希键的底层实现之一，当哈希键包含的键值对比较多，或者键值对中的元素比较长的字符串时，Redis使用字典作为hash键的底层实现。</li></ul><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><ul><li>hash表<ul><li>dict.h/dictht<ul><li>dictEntry **table<ul><li>哈希表数组</li><li>每一个dictEntry结构保存着一个键值对</li></ul></li><li>unsigned long size<ul><li>哈希表大小</li></ul></li><li>unsigned long sizemask<ul><li>哈希表大小掩码，用于计算索引值，总是等于size-1</li></ul></li><li>unsigned long used<ul><li>哈希表已有的节点的数量</li></ul></li></ul></li></ul></li><li>hash表节点<ul><li>dict.h/dictEntry<ul><li>void* key<ul><li>键</li></ul></li><li>union{void *val;uint64_tu64; int64_ts64} v;<ul><li>值</li></ul></li><li>struct dictEntry *next<ul><li>指向下个哈希表节点，形成链表</li><li>可以将多个哈希值相同的键值连接在一起，以此来解决键冲突问题。</li></ul></li></ul></li></ul></li><li>字典<ul><li>dict.h/dict<ul><li>dictType *type<ul><li>类型特定函数</li><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为用途不同的字典设置不同的特定类型函数<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzx8sofgdj30qa0ffq6e.jpg" alt=""></li></ul></li></ul></li><li>void *privdata<ul><li>私有数据</li></ul></li><li>dictht ht[2]<ul><li>哈希表</li></ul></li><li>int rehashidx<ul><li>rehash索引</li><li>当rehash不在进行时，值为-1</li></ul></li></ul></li><li>Hash算法<ul><li>使用字典设置的hash函数，计算key的hash值<ul><li>Redis使用MurmurHash2算法来计算键的哈希值</li></ul></li><li>使用哈希表的sizemask属性和哈希值，计算出索引值<ul><li>根据情况，ht[x]可以是ht[0]或ht[1]</li></ul></li></ul></li><li>解决键冲突<ul><li>Redis哈希表使用链地址法来解决键冲突<ul><li>因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，总是将新节点添加到表头位置</li></ul></li></ul></li><li>rehash<ul><li>哈希表中保存的键值会逐渐增多或减少，为了让哈希表的 <strong>负载因子</strong>(load factor)维持在一个合理的范围之内，程序需要对哈希表的大小进行相应的扩展或者收缩，通过执行<code>rehash</code>操作来完成<ul><li>为字典的<code>ht[1]</code>哈希表分配空间<ul><li>大小取决于ht[0]当前包含的键值对数量</li><li>以及要执行的操作<ul><li>若是扩展操作，则ht[1]大小为ht[0].used*2</li><li>若是收缩操作，则ht[1]大小为第一个大于等于ht[0].used的2的n次幂</li></ul></li></ul></li><li>将所有ht[0]中的键值对rehash到ht[1]上</li><li>释放ht[0]，将ht[1]设置为ht[0]，并为ht[1]新创建一个空白hashtable，为下一次rehash做准备</li></ul></li></ul></li><li>表的扩展与收缩<ul><li>扩展<ul><li>服务器目前没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>，并且load factor 大于等于1</li><li>服务器目前执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>，并且load factor 大于等于5</li><li>根据是否执行BGSAVE和BGREWRITEAOF，扩展所需的负载因子并不相同<ul><li>在执行上述两命令时，Redis需要创建服务器进程子进程，而大多数操作系统都采用 <strong>写时复制</strong> 来优化子进程使用效率，所以在子进程存在期间服务器提高负载因子阈值。</li></ul></li></ul></li><li>收缩<ul><li>当load factor小于0.1时，开始收缩操作</li></ul></li></ul></li><li>渐进式rehash<ul><li>如果哈希表中过多键值对，在rehash到ht[1]时可能会导致服务器在一段时期停止服务</li><li>因此，为了避免rehash对服务器性能有影响，rehash是分多次、渐进式进行的<ul><li>为ht[1]分配空间</li><li>字典中维持一个索引计数器变量<code>rehashidx</code>,初始值为0</li><li>rehash期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，rehashidx递增</li><li>随着字典操作不断执行，ht[0]最终全部被rehash，这时将rehashidx属性值设为-1，表示rehash已经完成</li></ul></li></ul></li><li>在渐进式rehash进行期间，对ht[0]的RUD操作，会在两个哈希表上进行<ul><li>查找键，现在ht[0]查找，否则在ht[1]上找</li><li>插入的键保存到ht[1]中，ht[0]不在进行任何添加操作</li></ul></li><li>字典API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzyhmpjybj30k606ijt4.jpg" alt=""></li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzyi7zsg2j30je02tq3n.jpg" alt=""></li></ul></li></ul></li></ul><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><ul><li>整数集合(intset)是集合键的底层实现之一<ul><li>当一个集合只包含整数值元素且元素数量不多时，Redis使用整数集合作为集合键的底层实现</li></ul></li><li>实现<ul><li>可以保存类型为int16_t、int32_t、int64_t</li><li>intset.h/intset<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fvzypl9z33j305z04r0sy.jpg" alt=""></li><li><code>contents</code>数组是整数集合的实现，每个项在数组中按值递增有序排列，且不包含任何重复项</li><li><code>length</code>记录了集合元素数量，也即contents数组长度</li><li>intset的contents数组并不保存任何int8_t类型的值，contents数组真正类型取决于encoding属性的值<ul><li>INTEST_ENC_INT16—&gt;int16_t</li><li>INTSET_ENC_INT32—&gt;int32_t</li><li>INTSET_ENC_INT64—&gt;int64_t</li></ul></li></ul></li></ul></li><li>升级<ul><li>当要讲一个新元素添加到整数集合里面，并且新元素的类型比整数集合元素类型都要长时，整数集合需要先进行升级<ul><li>根据新元素类型，扩展整数集合底层数组空间大小，并为新元素分配空间</li><li>将底层现有的所有元素都转换成与新元素相同的类型，在放置元素在正确位置的过程中，保证有序性</li><li>将新元素添加到底层数组里面</li></ul></li><li>升级的好处<ul><li>提升整数集合的灵活性<ul><li>随意将不同长度的整形数添加到集合中，而不必担心出现类型错误</li></ul></li><li>尽可能的节约内存<ul><li>不是直接用int64_t单元数组作为底层实现，而是只在需要的时候才扩展空间进行升级，可以尽量节省内存</li></ul></li></ul></li></ul></li><li>降级<ul><li>Redis整数集合不支持降级操作，编码一直保持升级后的状态</li></ul></li><li>整数集合API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw00rs8nz3j30jg06pq5b.jpg" alt=""></li></ul></li></ul><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><ul><li>压缩列表是列表键和哈希键的底层实现之一<ul><li>列表键只包含少量列表项<ul><li>每个列表项是小整数值或长度较短的字符串</li></ul></li><li>哈希键只包含少量键值对<ul><li>每个键值对的键值是小整数值或长度比较短的字符串</li></ul></li></ul></li><li>压缩列表的构成<ul><li>为了节约内存而开发，是由一系列特殊编码的连续内存块组成的顺序性(sequential)数据结构。<ul><li>一个压缩列表包含任意多节点（entry），每个节点保存一个字节数组或者一个整数值</li></ul></li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0k0c92anj30j606dtbi.jpg" alt=""></li><li>每个压缩列表节点可以保存一个字节数组或者一个整数值<ul><li>字节数组<ul><li>长度小于2的6次幂-1字节</li><li>长度小于2的14次幂-1字节</li><li>长度小于2的32次幂-1字节</li></ul></li><li>整数值<ul><li>四位长，0~12之间的无符号整数</li><li>1字节的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t,int32_t,int64_t</li></ul></li><li>每个压缩列表节点<ul><li>previous_entry_length<ul><li>以字节为单位，记录前一个节点的长度</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0kmzomunj30i903at9y.jpg" alt=""></li><li>程序可以通过指针运算，根据当前节点的起始地址来计算前一个节点的起始地址</li><li>压缩列表从表尾向表头遍历操作就是这一原理实现</li></ul></li><li>encoding<ul><li>encoding属性记录了节点的content属性所保存数据的类型以及长度<ul><li>一字节、两字节或五字节长，值的最高位为00,01或者10的是 <strong>字节数组编码</strong><ul><li>表示节点的content属性保存字节数组，数组长度由编码除去最高两位之后的其它位记录</li></ul></li><li>一字节长，值的最高位以11开头的是 <strong>整数编码</strong><ul><li>content属性保存着整数值、整数值的类型和长度由编码除去最高两位之后的其他位记录</li><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0lki8wh6j30ja05gmyx.jpg" alt=""></li></ul></li></ul></li></ul></li><li>content<ul><li>负责保存节点的值</li></ul></li></ul></li></ul></li></ul></li><li>连锁更新<ul><li>假设一种情况（添加新节点）<ul><li>在一个压缩列表中，有多个连续的、长度介于250到253字节的节点<ul><li>因为e1到en的所有节点长度都小于254字节，所以只需要一字节长的previous_entry_length属性</li></ul></li><li>这是，如果将一个长度大于等于254字节的new节点插入到表头节点，那么new节点将成为e1前置节点</li><li>由于e1的previous_entry_length属性只有一字节，无法保存new节点的长度，因此对压缩列表执行 <strong>空间重分配操作</strong>，并将e1节点的previous_entry_length属性扩展到五字节</li><li>e1长度原本介于250到253字节，但经过previous_entry_length扩展字节后，长度超过254字节，为了让e2的previous_entry_length可以记录下e1节点的长度，再次进行空间重分配，将e2的previous_entry_length扩展到五字节</li><li>以此类推：扩展e1引发对e2扩展，同样引发对e3扩展…知道eN为止</li></ul></li><li>另一种情况（删除新节点）<ul><li>如果e1至eN都是长度介于250~253之间的节点，而e1之前的big(表头节点，大于254)和small节点（big之后，小于254）.</li><li>将small节点从压缩列表中删除之后，e1的previous_entry_length就从保存small长度变为保存big长度，因此需要重新分配空间，扩展precious_entry_length到5字节</li><li>e1长度经过扩展超过254字节，因此引发了后续的连锁扩展</li></ul></li><li>复杂度<ul><li>最坏情况下需要执行N次空间重分配操作，每次分配最坏复杂度为O(N)，所以每次连锁更新复杂度为O(N²)</li><li>虽然复杂度较高，但进行连锁更新的概率较低</li></ul></li></ul></li><li>压缩列表API<ul><li><img src="http://ww1.sinaimg.cn/large/006F6RCUly1fw0lnr6xvsj30j10bwq76.jpg" alt=""></li><li><code>ziplistPush</code>、<code>ziplistInsert</code>、<code>ziplistDelete</code>、<code>ziplistDelete</code>都有可能引发连锁更新</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJ 1006 Biorhythms</title>
      <link href="/posts/2811150533/"/>
      <url>/posts/2811150533/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1006" target="_blank" rel="noopener">题目链接</a><br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目较易理解，大致思路就是寻找三个生理周期高峰出现在同一天的日期，除此之外题目中给了变量<code>d</code>，即相对于日期<code>d</code>的天数（当然，<code>d</code>可以小于三个周期的周期天数）。</p><h3 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h3><ul><li>最容易想到的就是遍历每一天，直到找到符合要求的为止，最大不超过<code>21252</code>(三个周期的最小公倍数)</li></ul><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3>]]></content>
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>test_my_site</title>
      <link href="/posts/1965421688/"/>
      <url>/posts/1965421688/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1243066710/"/>
      <url>/posts/1243066710/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
